# Prompt 11: VIBE Tab — Conversational Development Pipeline

## CONTEXT

ProjectStats is a native macOS developer dashboard (~31k LOC, 184 Swift files). It has a tabbed workspace with embedded SwiftTerm terminals, prompt composition, template management, and terminal output monitoring.

**What we're building:** A new tab type called "VIBE" that collapses the entire development pipeline — ideation → planning → prompt generation → execution → monitoring — into a single view. Instead of bouncing between Claude.ai for planning, the prompt helper for composition, and the terminal for execution, everything happens in one place.

**How it works under the hood:** The user chats with Claude Code inside a terminal (using `/plan` mode for ideation). The terminal output is already being captured by `TerminalOutputMonitor` — we just need to also save it. The user refines their idea conversationally, then tells Claude to save the plan. The plan gets the prompt template applied, and the user can fire it off for execution in a separate terminal — all without leaving the VIBE tab.

**Key insight:** Claude Code's conversation is a continuous stream, not turn-based. The user can type at any time, even while Claude is responding. The "chat UI" is really just a styled terminal output view with a nicer input box. Don't try to parse turns or make chat bubbles — just show the stream.


## WHAT EXISTS (do NOT break these)

- `TerminalTabKind` enum: `.shell`, `.claude`, `.ccYolo`, `.codex`, `.devServer`, `.ghost`
- `TerminalTabItem` class with `sendCommand()`, `enqueueCommand()`, `recordOutput()`, `attach()`
- `TerminalTabsViewModel` (shared) manages terminal tabs per project
- `MonitoringTerminalView` subclass of `LocalProcessTerminalView` — captures all output via `dataReceived()`
- `TerminalOutputMonitor` — processes every line, detects Claude start/end, strips ANSI
- `PromptHelperComposer.compose()` — merges user text with template (`{PROMPT}` replacement)
- `ThinkingLevelService.generatePromptCommand()` — builds the `claude --model X "prompt"` shell command
- `TabContent` enum: `.home`, `.projectPicker`, `.projectWorkspace(projectPath:)`
- `AppTab` struct with `id`, `content`, `isPinned`, `title`, `icon`
- `TabManagerViewModel` manages app-level tabs
- `PromptTemplate` SwiftData model with versioning, `isDefault`, `{PROMPT}` placeholder
- `SavedPrompt` SwiftData model
- `PromptExecutionTracker` for tracking execution start/end
- All existing tests must continue to pass


## SCOPE A — Fix AIModel Version Pinning

**Problem:** `AIModel` raw values use full version-dated strings (e.g., `claude-sonnet-4-20250514`). When `ThinkingLevelService.generateClaudeCommand()` builds the command, it passes `--model claude-sonnet-4-20250514` instead of the short name Claude Code expects.

**Fix:**
1. Change `generateClaudeCommand()` to use short model names for Claude models when building CLI commands. Add a `cliName` computed property to `AIModel`:
   - `.claudeSonnet4` → `"sonnet"` (or omit `--model` entirely since it's default)
   - `.claudeOpus4` → `"opus"`
   - `.claudeHaiku4` → `"haiku"`
   - `.claudeOpus46` → `"claude-opus-4-6"`
   - `.claudeSonnet45` → `"claude-sonnet-4-5-20250929"`
   - `.claudeHaiku45` → `"claude-haiku-4-5-20251001"`
   - For the 4.5/4.6 series, keep the full strings since those ARE the correct identifiers
   - Non-Claude models keep their existing raw values
2. Update `generateClaudeCommand()` and `generatePromptCommand()` to use `cliName` instead of `rawValue`
3. Do NOT change the `rawValue` itself — that would break SwiftData/Codable persistence

**Tests:**
- `test_A_cliName_returnsShortNames` — verify each Claude model returns correct CLI name
- `test_A_generateCommand_usesCliName` — verify generated commands use short names


## SCOPE B — VibeConversation SwiftData Model

**Create:** `Models/VibeConversation.swift`

A SwiftData model to persist VIBE tab conversations.

```
@Model VibeConversation {
    var id: UUID
    var projectPath: String
    var startedAt: Date
    var updatedAt: Date
    var title: String                    // user-editable, defaults to "Vibe Session - [date]"
    var rawLog: String                   // full terminal output, ANSI-stripped
    var status: String                   // "planning", "ready", "executing", "completed"
    var planSummary: String?             // Claude's plan description (part 1)
    var composedPrompt: String?          // template-applied prompt (part 2)
    var executionDurationSeconds: Double?
    var templateId: UUID?                // which PromptTemplate was applied
}
```

Keep it simple. One model, no relationships for now.

**Tests:**
- `test_B_vibeConversation_creation` — create, verify defaults
- `test_B_vibeConversation_statusTransitions` — planning → ready → executing → completed


## SCOPE C — VibeConversationService

**Create:** `Services/VibeConversationService.swift`

A lightweight service that manages the active VIBE conversation.

```
@MainActor
final class VibeConversationService: ObservableObject {
    static let shared = VibeConversationService()

    @Published var activeConversation: VibeConversation?

    func startConversation(projectPath: String) -> VibeConversation
    func appendToLog(_ text: String)        // appends ANSI-stripped text to rawLog
    func lockPlan(summary: String)          // sets planSummary, status → "ready"
    func composePrompt(templateContent: String?) // applies template, sets composedPrompt
    func startExecution()                   // status → "executing"
    func completeExecution(duration: Double) // status → "completed"
    func endConversation()                  // saves, clears activeConversation
}
```

`appendToLog` should debounce writes to SwiftData — buffer in memory, flush every ~2 seconds or on explicit save. Don't write to disk on every terminal chunk.

**Tests:**
- `test_C_startConversation_createsModel`
- `test_C_appendToLog_buffersAndFlushes`
- `test_C_lockPlan_setsStatusReady`
- `test_C_composePrompt_appliesTemplate` — test with `{PROMPT}` replacement and without


## SCOPE D — TabContent + TabManager: Add .vibe Case

**Modify:** `Models/AppTab.swift`
- Add `case vibe(projectPath: String)` to `TabContent`
- Add `Equatable` case
- Title: "Vibe" (or project name + "Vibe")
- Icon: `"bolt.fill"` (or `"waveform"`)

**Modify:** `ViewModels/TabManagerViewModel.swift`
- Add `func openVibeTab(projectPath: String)` — creates a new `.vibe` tab or focuses existing one for that project
- Handle `.vibe` in any `switch` statements on `TabContent` (serialization, restoration, etc.)

**Modify:** Wherever `TabContent` is switched on in views (check `WorkspaceView.swift` and any view that renders tab content) — add the `.vibe` case, rendering `VibeTabView` (which we build in Scope F).

**Tests:**
- `test_D_vibeTabContent_equality`
- `test_D_openVibeTab_createsTab`


## SCOPE E — VibeTerminalBridge

**Create:** `Services/VibeTerminalBridge.swift`

This bridges the VIBE tab's UI to the underlying terminal. It manages a `TerminalTabItem` that may or may not be visible.

```
@MainActor
final class VibeTerminalBridge: ObservableObject {
    let projectPath: URL
    @Published var outputStream: String = ""     // running terminal output for display
    @Published var isClaudeActive: Bool = false

    private var terminalTab: TerminalTabItem
    private let conversationService = VibeConversationService.shared

    init(projectPath: URL)

    func boot()                          // starts the terminal process, sends "claude /plan"
    func send(_ text: String)            // sends user input to terminal
    func sendSlashCommand(_ cmd: String) // sends /plan, /usage, etc.
    func lockPlanAndCompose(summary: String, template: PromptTemplate?)
    func executePrompt()                 // opens new terminal tab with composed prompt, switches to execution monitoring
}
```

**Output handling:** Hook into the terminal's output stream (same pattern as `MonitoringTerminalView.onOutput`). Every chunk:
1. Strip ANSI → append to `outputStream` (for display)
2. Pass to `conversationService.appendToLog()` (for persistence)
3. Pass to `TerminalOutputMonitor.shared.processTerminalChunk()` (for existing Claude detection)

**For `boot()`:** Create a `TerminalTabItem(kind: .claude)`, start the shell process pointing at `projectPath`, then `enqueueCommand("claude")` followed by a short delay and `enqueueCommand("/plan")` to enter plan mode.

**For `executePrompt()`:** Use the existing `PromptHelperView` pattern — create a new `TerminalTabItem(kind: .claude)`, compose the command via `ThinkingLevelService.generatePromptCommand()`, enqueue it. Monitor this second terminal's output for the execution view.

**Keep `outputStream` trimmed** — if it exceeds ~500KB, trim the oldest content. The full log is in `VibeConversation.rawLog` anyway.

**Tests:**
- `test_E_send_appendsToOutputStream`
- `test_E_boot_startsClaudeInPlanMode`


## SCOPE F — VibeTabView (The Main UI)

**Create:** `Views/Vibe/VibeTabView.swift`

The main VIBE tab view. Layout:

```
┌──────────────────────────────────────────────────────┐
│ [Project Dropdown ▼]  [/plan toggle]  [status badge] │
├──────────────────────────────────────────────────────┤
│                                                      │
│  Terminal output stream                              │
│  (ScrollView, monospaced, ANSI-stripped)             │
│  Read-only. Auto-scrolls to bottom.                  │
│  Shows everything Claude outputs.                    │
│                                                      │
│                                                      │
│                                                      │
├──────────────────────────────────────────────────────┤
│ [input field                        ] [Send]         │
│ [Lock Plan ☐]  [Execute ▶]  [template picker]       │
├──────────────────────────────────────────────────────┤
│ ─── Execution Monitor (collapsible) ───              │
│ [execution output stream, read-only, when running]   │
└──────────────────────────────────────────────────────┘
```

**Components:**

1. **Header bar:** Project dropdown (populated from `DashboardViewModel.shared` projects list), `/plan` toggle button (sends `/plan` to terminal), status badge showing conversation status from `VibeConversationService`

2. **Output stream:** `ScrollViewReader` + `Text` displaying `VibeTerminalBridge.outputStream`. Monospaced font. Auto-scroll to bottom on new content (with a "scroll lock" toggle so user can scroll up without being yanked down). Read-only — no interaction.

3. **Input area:** `TextField` with send button. Command+Return to send. Always active. Sends to `VibeTerminalBridge.send()`. Input also appears in the output stream (because it goes to the terminal and comes back through output).

4. **Action bar:**
   - "Lock Plan" button — shows a sheet/popover asking for plan summary (or Claude can provide it). On confirm, calls `VibeTerminalBridge.lockPlanAndCompose()`. Once locked, the "Execute" button enables.
   - "Execute" button — disabled until plan is locked and prompt is composed. On click, calls `VibeTerminalBridge.executePrompt()`.
   - Template picker — same pattern as `PromptHelperView`'s picker, shows available `PromptTemplate`s from SwiftData.

5. **Execution monitor panel:** Collapsible bottom panel. Only shows when execution is in progress. Displays the execution terminal's output stream (read-only, same styled-terminal treatment). Shows a timer. Detects completion via `✻ Cooked for` pattern.

**Tests:**
- `test_F_vibeTabView_rendersWithProject` — basic view creation test


## SCOPE G — Wire It All Together + Entry Points

**Create entry points to open a VIBE tab:**

1. **Home page:** Add a "Start Vibing" or "VIBE" button somewhere accessible (follow existing button patterns on the home page layout). Clicking opens a VIBE tab.

2. **Project workspace toolbar:** Add a "VIBE" button to the project toolbar (near existing terminal/prompt buttons). Opens a VIBE tab pre-selected to that project.

3. **Keyboard shortcut:** `Cmd+Shift+V` opens a new VIBE tab.

**Wire the output pipeline:**
- When a VIBE tab's terminal produces output, it flows through:
  `MonitoringTerminalView.dataReceived()` → `onOutput` closure → `VibeTerminalBridge` (updates outputStream + conversationService) → `TerminalOutputMonitor` (existing detection)

**Wire execution completion:**
- When execution terminal detects `✻ Cooked for X`, call `conversationService.completeExecution(duration:)` and update the UI to show "Done!"

**Tests:**
- `test_G_openVibeTab_fromHomePage`
- `test_G_executionCompletion_updatesStatus`


## SCOPE H — Haiku Summarizer Agent

**Create:** `Services/VibeSummarizerService.swift`

When a VIBE conversation gets long (or on user request), invoke Haiku to summarize.

```
@MainActor
final class VibeSummarizerService {
    static let shared = VibeSummarizerService()

    func summarize(conversation: VibeConversation) async -> String?
}
```

**Implementation:** Create a hidden `TerminalTabItem(kind: .ghost)`. Build a command:
```
claude --model haiku "Summarize the following development conversation. Extract: key decisions, technical requirements, open questions, and the final agreed plan. Be concise.\n\n[conversation.rawLog truncated to last ~50k chars]"
```

Send to the ghost terminal. Capture output. Save summary to `VibeConversation.planSummary`.

**Problem:** The prompt text might be too long for a shell argument. If `rawLog` is large, write it to a temp file and use `claude --model haiku "Read /tmp/vibe_summary_[uuid].txt and summarize..."` instead. Clean up the temp file after.

**Add a "Summarize" button** to the VIBE tab header bar. Shows a spinner while Haiku works. Displays the summary in a popover or inline panel when done.

**Tests:**
- `test_H_summarize_buildsCommand`
- `test_H_summarize_handlesLargeLog` — verify temp file approach for logs > 10k chars


## PROJECT-SPECIFIC RULES

- CRITICAL: Never use NSWindow level `.screenSaver` — it locks out macOS Force Quit. Use `.floating` or `.statusBar` max.
- Follow existing patterns: singletons with `.shared`, `@MainActor`, `@Published`
- Use existing `AppModelContainer.shared.mainContext` for SwiftData operations
- Use existing `SettingsViewModel.shared` for any settings
- Terminal commands go through `TerminalTabItem.sendCommand()` / `enqueueCommand()`
- ANSI stripping uses the existing `stripAnsiCodes()` pattern (regex: `\\x1B\\[[0-9;]*[a-zA-Z]`)
- The VIBE tab is additive — do NOT modify existing project workspace views, terminal behavior, or prompt helper functionality


---

You must follow this 4-part response structure for the overall task:

1. **Plan:** Outline moves in order. State what you will NOT touch.
2. **Difficulty:** Brief estimate and likely failure points.
3. **Execute:** Do the work with strict discipline. Minimal edits. One scope at a time.
4. **Report + Self-Grade:** What changed, why, grade yourself (A–F). Be brutally honest.


## ENGINEERING PHILOSOPHY (NON-NEGOTIABLE)

- Write the simplest, most direct solution possible. Less code is better code.
- Do not over-engineer. Do not add abstractions unless explicitly needed.
- If there's a 10-line solution and a 40-line solution, write the 10-line solution.
- Clever code is bad code. Readable code is good code.
- TDD is mandatory. Write tests FIRST for every scope. Tests are cheap insurance.
  Spending 5% more tokens on tests saves 5x the tokens fixing dumb shit later.


## PROCESS RULES (NON-NEGOTIABLE)

- Follow existing patterns in the codebase. Do not reinvent.
- All existing tests must continue to pass.
- Commit after completing EACH scope. Do not batch.
- Build must pass before moving to the next scope.
- If stuck on a scope for >10 minutes, add a TODO comment and move on.
- No new dependencies unless specified in scope.
- No changes to existing terminal behavior, prompt helper, or workspace views unless explicitly stated.
- Do NOT modify the SwiftData model container registration without checking `AppModelContainer` first — add `VibeConversation` to the schema list.


## COMMIT DISCIPLINE (NON-NEGOTIABLE)

After completing EACH scope:
1. Run the full test suite. All tests must pass.
2. Run the build. Build must succeed.
3. Commit with message format: "[Scope Letter] - [Brief description]"
   Example: "A - Fix AIModel CLI name version pinning"
4. Create stats artifact (see REPORTING section below).
5. Continue to next scope.

After ALL scopes are complete:
- Push to main.
- Report all commit hashes in final response.


## TDD PROTOCOL (NON-NEGOTIABLE)

For EVERY scope:
1. Write the test(s) FIRST — they should fail.
2. Write the minimum code to make them pass.
3. Refactor if needed (tests still pass).
4. Commit.

Test naming: `test_[Scope]_[Behavior]` or descriptive Swift convention.
New test count must be reported in the final summary.


## PROMPT ARCHIVAL (NON-NEGOTIABLE)

Before starting ANY work, save this entire prompt to:
`/prompts/11.md`

This is the project's black box. Every prompt is recorded.


## REPORTING — WORK LOG (NON-NEGOTIABLE)

When ALL scopes are complete, create a closing work log at:
`/work/YYYY-MM-DD_HHMM_vibe-tab.md`
Timezone: CST (America/Chicago)
Use: `TZ='America/Chicago' date '+%Y-%m-%dT%H:%M:%S CST'`

Contents:
```
Work Log: VIBE Tab — Conversational Development Pipeline
Prompt Summary:
[2-3 sentence summary]

Scopes Completed:
* [A] Fix AIModel version pinning — [status]
* [B] VibeConversation SwiftData model — [status]
* [C] VibeConversationService — [status]
* [D] TabContent + TabManager .vibe case — [status]
* [E] VibeTerminalBridge — [status]
* [F] VibeTabView UI — [status]
* [G] Entry points + wiring — [status]
* [H] Haiku summarizer agent — [status]

Results:
* Commits: [count] ([hashes])
* Files created: [count]
* Files modified: [count]
* Tests: [X existing + Y new = Z total passing]
* Build: [pass/fail]

Self-Grade: [A-F]
[Honest justification]
```
