--- a/projectStats/projectStats/Models/Project.swift
+++ b/projectStats/projectStats/Models/Project.swift
@@ -1,200 +1,202 @@
 import Foundation
 
 struct GitHubStats {
     var stars: Int = 0
     var forks: Int = 0
     var openIssues: Int = 0
     var watchers: Int = 0
 }
 
 enum ProjectStatus: String, CaseIterable {
     case active = "Active"
     case inProgress = "In Progress"
     case dormant = "Dormant"
 
     var color: String {
         switch self {
         case .active:
             return "green"
         case .inProgress:
             return "blue"
         case .dormant:
             return "gray"
         }
     }
 }
 
 struct Project: Identifiable, Hashable {
     let id: UUID
     let path: URL
     let name: String
     var description: String?
     var githubURL: String?
     var language: String?
     var lineCount: Int
     var fileCount: Int
     var promptCount: Int
     var workLogCount: Int
     var lastCommit: Commit?
     var lastScanned: Date
     var status: ProjectStatus = .active
     var notes: String?
     var tags: [String] = []
     var githubStats: GitHubStats?
+    var githubStatsError: String?
 
     init(
         id: UUID = UUID(),
         path: URL,
         name: String,
         description: String? = nil,
         githubURL: String? = nil,
         language: String? = nil,
         lineCount: Int = 0,
         fileCount: Int = 0,
         promptCount: Int = 0,
         workLogCount: Int = 0,
         lastCommit: Commit? = nil,
         lastScanned: Date = Date(),
         status: ProjectStatus = .active,
         notes: String? = nil,
         tags: [String] = [],
-        githubStats: GitHubStats? = nil
+        githubStats: GitHubStats? = nil,
+        githubStatsError: String? = nil
     ) {
         self.id = id
         self.path = path
         self.name = name
         self.description = description
         self.githubURL = githubURL
         self.language = language
         self.lineCount = lineCount
         self.fileCount = fileCount
         self.promptCount = promptCount
         self.workLogCount = workLogCount
         self.lastCommit = lastCommit
         self.lastScanned = lastScanned
         self.status = status
         self.notes = notes
         self.tags = tags
         self.githubStats = githubStats
+        self.githubStatsError = githubStatsError
     }
 
     func hash(into hasher: inout Hasher) {
         hasher.combine(id)
     }
 
     static func == (lhs: Project, rhs: Project) -> Bool {
         lhs.id == rhs.id
     }
 }
--- a/projectStats/projectStats/ViewModels/DashboardViewModel.swift
+++ b/projectStats/projectStats/ViewModels/DashboardViewModel.swift
@@ -1,250 +1,274 @@
 import Foundation
 import SwiftUI
 
 @MainActor
 class DashboardViewModel: ObservableObject {
     @Published var projects: [Project] = []
     @Published var activities: [Date: ActivityStats] = [:]
     @Published var aggregatedStats: AggregatedStats = .empty
     @Published var isLoading = false
     @Published var selectedProject: Project?
 
     private let scanner = ProjectScanner.shared
     private let gitService = GitService.shared
     private let githubClient = GitHubClient.shared
 
     init() {
         Task {
             await loadData()
         }
     }
 
     func loadData() async {
         isLoading = true
         defer { isLoading = false }
 
         let codeDirectory = SettingsViewModel.shared.codeDirectory
 
         // Scan projects
         projects = await scanner.scan(directory: codeDirectory)
 
         // Calculate activities from all projects
         await calculateActivities()
 
         // Calculate aggregated stats
         calculateAggregatedStats()
 
         // Fetch GitHub stats if authenticated
         await fetchGitHubStats()
     }
 
     func refresh() async {
+        if isLoading { return }
         await loadData()
     }
 
     private func calculateActivities() async {
         var allActivities: [Date: ActivityStats] = [:]
 
         for project in projects {
             let projectActivities = gitService.getDailyActivity(at: project.path, days: 365)
 
             for (date, activity) in projectActivities {
                 if var existing = allActivities[date] {
                     existing.commits += activity.commits
                     existing.linesAdded += activity.linesAdded
                     existing.linesDeleted += activity.linesDeleted
                     allActivities[date] = existing
                 } else {
                     allActivities[date] = activity
                 }
             }
         }
 
         activities = allActivities
     }
 
     private func calculateAggregatedStats() {
         var today = DailyStats()
         var thisWeek = DailyStats()
         var thisMonth = DailyStats()
         var total = DailyStats()
 
         let now = Date()
         let calendar = Calendar.current
         let startOfWeek = calendar.startOfWeek(for: now)
         let startOfMonth = calendar.date(from: calendar.dateComponents([.year, .month], from: now)) ?? now
 
         for (date, activity) in activities {
             let stats = DailyStats(
                 linesAdded: activity.linesAdded,
                 linesDeleted: activity.linesDeleted,
                 commits: activity.commits
             )
 
             total.linesAdded += stats.linesAdded
             total.linesDeleted += stats.linesDeleted
             total.commits += stats.commits
 
             if calendar.isDate(date, inSameDayAs: now) {
                 today.linesAdded += stats.linesAdded
                 today.linesDeleted += stats.linesDeleted
                 today.commits += stats.commits
             }
 
             if date >= startOfWeek {
                 thisWeek.linesAdded += stats.linesAdded
                 thisWeek.linesDeleted += stats.linesDeleted
                 thisWeek.commits += stats.commits
             }
 
             if date >= startOfMonth {
                 thisMonth.linesAdded += stats.linesAdded
                 thisMonth.linesDeleted += stats.linesDeleted
                 thisMonth.commits += stats.commits
             }
         }
 
         aggregatedStats = AggregatedStats(
             today: today,
             thisWeek: thisWeek,
             thisMonth: thisMonth,
             total: total
         )
     }
 
     func fetchGitHubStats() async {
         githubClient.refreshAuthStatus()
         guard githubClient.isAuthenticated else { return }
 
+        var failures: [(repo: String, error: Error)] = []
+
         for i in projects.indices {
             guard let urlString = projects[i].githubURL,
                   let (owner, repo) = GitHubClient.parseGitHubURL(urlString) else {
                 continue
             }
 
             do {
                 let repoInfo = try await githubClient.getRepo(owner: owner, repo: repo)
                 projects[i].githubStats = GitHubStats(
                     stars: repoInfo.stargazersCount,
                     forks: repoInfo.forksCount,
                     openIssues: repoInfo.openIssuesCount
                 )
+                projects[i].githubStatsError = nil
             } catch {
-                print("Failed to fetch GitHub stats for \(repo): \(error)")
+                projects[i].githubStats = nil
+                projects[i].githubStatsError = String(describing: error)
+                failures.append((repo: "\(owner)/\(repo)", error: error))
+                continue
             }
         }
+
+        if !failures.isEmpty {
+            let summary = failures
+                .map { "\($0.repo): \($0.error)" }
+                .joined(separator: "\n")
+            print("GitHub stats fetch failures (\(failures.count)):\n\(summary)")
+        }
     }
 }