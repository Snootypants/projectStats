# Prompt 13: Fix XP & Achievement System — Make It Actually Work

## CONTEXT

The XP/Achievement system is fundamentally broken. There are 22 achievements defined but only 6 have trigger code, and even those don't work properly. The core problem: XP is only awarded from one-time achievement unlocks. Once you unlock First Blood (25 XP) on day 1, you never earn XP again unless you're coding at 3am or pushing on Fridays. Normal daily development — commits, pushes, prompts, Claude sessions — generates zero XP after that first day.

**What needs to happen:**
1. Add activity-based XP that accumulates from regular development work
2. Wire the 16 dead achievements so they actually trigger
3. Make the daily First Blood check award XP every day (not just on first unlock)


## WHAT EXISTS (do NOT break)

- `Achievement` enum — 22 achievements with title, description, icon, points, rarity
- `AchievementUnlock` SwiftData model — tracks which achievements are unlocked
- `AchievementService` — singleton, `checkAndUnlock()`, `onGitPushDetected()`, `@AppStorage` counters
- `TerminalOutputMonitor` — detects git commits (`[main `), git pushes (`To github.com`), Claude start/end
- `TimeTrackingService` — tracks active coding time per project
- `AISessionV2` SwiftData model — tracks Claude sessions with timestamps
- `SavedPrompt` SwiftData model — tracks executed prompts
- `PromptExecutionTracker` — tracks prompt execution start/end
- `CachedDailyActivity` SwiftData model — daily stats per project (lines added/removed, commits, files changed)
- XP bar in the top-right corner of the app (`25 / 250 XP`, `Lvl 1`)
- Home page shows achievements


## SCOPE A — Activity XP System

**Create:** `Services/XPService.swift`

A service that awards XP for regular development activity. This is separate from achievement XP.

```
@MainActor
final class XPService: ObservableObject {
    static let shared = XPService()

    @AppStorage("xp.totalXP") var totalXP: Int = 0
    @AppStorage("xp.currentLevel") var currentLevel: Int = 1
    @AppStorage("xp.lastDailyBonusDate") private var lastDailyBonusDate: String = ""
    @AppStorage("xp.currentStreak") var currentStreak: Int = 0
    @AppStorage("xp.lastStreakDate") private var lastStreakDate: String = ""

    @Published var recentXPGain: (amount: Int, reason: String)?

    // XP amounts
    static let xpPerCommit = 5
    static let xpPerPush = 10
    static let xpPerPromptExecuted = 10
    static let xpPerClaudeSession = 5
    static let xpDailyBonus = 15
    static let xpPerHourCoding = 10

    // Level thresholds: level N requires N * 250 XP total
    // Level 1: 0, Level 2: 250, Level 3: 500, Level 4: 750, etc.

    func awardXP(amount: Int, reason: String)
    func onCommitDetected(projectPath: String)
    func onPushDetected(projectPath: String)
    func onPromptExecuted(projectPath: String)
    func onClaudeSessionCompleted(projectPath: String)
    func checkDailyBonus()
    func updateStreak()

    var xpForNextLevel: Int  // total XP needed for next level
    var xpProgressInLevel: Int  // XP earned within current level
    var streakMultiplier: Double  // day 1-2: 1.0, day 3-6: 1.5, day 7+: 2.0
}
```

**`awardXP` should:**
1. Apply streak multiplier to the amount
2. Add to `totalXP`
3. Check if level up occurred
4. Set `recentXPGain` for UI feedback (auto-clears after 3 seconds)
5. If level up: send notification via `NotificationService`

**`updateStreak` should:**
1. Check if `lastStreakDate` was yesterday → increment `currentStreak`
2. If `lastStreakDate` was today → do nothing (already counted)
3. If `lastStreakDate` was >1 day ago → reset `currentStreak` to 1
4. Update `lastStreakDate` to today

**`checkDailyBonus` should:**
1. If `lastDailyBonusDate` != today → award `xpDailyBonus`, update date, call `updateStreak()`
2. Called on first commit/push/session of the day

**Tests:**
- `test_A_awardXP_incrementsTotal`
- `test_A_levelUp_calculatesCorrectly` — verify level thresholds
- `test_A_streakMultiplier_appliesCorrectly`
- `test_A_dailyBonus_onlyOncePerDay`
- `test_A_streak_resetsAfterMissedDay`


## SCOPE B — Wire XP Triggers Into Existing Monitors

**Modify:** `TerminalOutputMonitor.swift`

In the git commit detection block (where it already calls `AchievementService`), also call:
```swift
XPService.shared.onCommitDetected(projectPath: projectPath)
```

In the git push detection block, also call:
```swift
XPService.shared.onPushDetected(projectPath: projectPath)
```

In the Claude session end block (where it already calls `PromptExecutionTracker`), also call:
```swift
XPService.shared.onClaudeSessionCompleted(projectPath: activeProjectPath ?? "")
```

**Modify:** `PromptHelperView.swift` (in `sendToClaudeCode()`)

After the prompt is saved to SwiftData, also call:
```swift
XPService.shared.onPromptExecuted(projectPath: projectPath.path)
```

Also add it in `VibeTerminalBridge.executePrompt()` for VIBE tab prompts.

**Tests:**
- `test_B_commitDetected_awardsXP`
- `test_B_pushDetected_awardsXP`


## SCOPE C — Wire All 16 Dead Achievements

**Modify:** `AchievementService.swift`

Add new check methods and wire them into existing trigger points:

### Streak achievements (wire into `checkFirstCommitOfDay`):
```swift
func checkStreakAchievements(projectPath: String) {
    let streak = XPService.shared.currentStreak
    if streak >= 7 { checkAndUnlock(.weekWarrior, projectPath: projectPath) }
    if streak >= 30 { checkAndUnlock(.monthlyMaster, projectPath: projectPath) }
}
```
Call from `checkFirstCommitOfDay` after updating the date.

For `.streakSurvivor`: When `XPService.updateStreak()` resets from >7 days back to 1, set `@AppStorage("achievement.hadLongStreak") = true`. When streak reaches 3 again AND `hadLongStreak` is true, unlock it.

### Session-based achievements (wire into Claude session end in `TerminalOutputMonitor`):
```swift
func checkSessionAchievements(projectPath: String) {
    // AI Whisperer — 100 Claude sessions
    let context = AppModelContainer.shared.mainContext
    let count = (try? context.fetchCount(FetchDescriptor<AISessionV2>())) ?? 0
    if count >= 100 { checkAndUnlock(.aiWhisperer, projectPath: projectPath) }
}
```

### Prompt-based achievements (wire into prompt save in `PromptHelperView` and VIBE execute):
```swift
func checkPromptAchievements(projectPath: String) {
    let context = AppModelContainer.shared.mainContext
    let count = (try? context.fetchCount(FetchDescriptor<SavedPrompt>())) ?? 0
    if count >= 50 { checkAndUnlock(.promptEngineer, projectPath: projectPath) }
}
```

### Time-based achievements (wire into `TimeTrackingService` or check periodically):
```swift
func checkDailyTimeAchievements(projectPath: String) {
    let todaySeconds = TimeTrackingService.shared.todayTotalSeconds
    if todaySeconds >= 8 * 3600 { checkAndUnlock(.marathoner, projectPath: projectPath) }
}
```
Call this when a Claude session ends (good proxy for "user is actively working").

### Speed achievement — Sprinter:
```swift
func checkSprinterAchievement(promptDuration: Double, projectPath: String) {
    // Shipped a feature (prompt execution) in under 1 hour
    if promptDuration > 0 && promptDuration < 3600 {
        checkAndUnlock(.sprinter, projectPath: projectPath)
    }
}
```
Wire into `PromptExecutionTracker.completeExecution()` or `TerminalOutputMonitor` where duration is already parsed.

### Line-count achievements (wire into project sync/refresh in `DashboardViewModel`):
```swift
func checkLineCountAchievements(projectPath: String, weeklyLinesAdded: Int, weeklyLinesRemoved: Int) {
    if weeklyLinesAdded >= 10_000 { checkAndUnlock(.novelist, projectPath: projectPath) }
    if weeklyLinesRemoved > weeklyLinesAdded { checkAndUnlock(.minimalist, projectPath: projectPath) }
    if weeklyLinesRemoved >= 1_000 { checkAndUnlock(.refactorer, projectPath: projectPath) }
}
```
Call this during the dashboard sync cycle where daily activity is calculated. The data is already in `CachedDailyActivity`.

### Multi-project achievements (check during dashboard refresh):
```swift
func checkProjectDiversityAchievements() {
    let context = AppModelContainer.shared.mainContext
    let today = Calendar.current.startOfDay(for: Date())

    // Multi-Tasker: 5 projects in one day
    var descriptor = FetchDescriptor<CachedDailyActivity>()
    // predicate: date == today, group by projectPath
    let activities = (try? context.fetch(descriptor)) ?? []
    let todayActivities = activities.filter { Calendar.current.isDate($0.date, inSameDayAs: today) }
    let uniqueProjects = Set(todayActivities.map { $0.projectPath })
    if uniqueProjects.count >= 5 { checkAndUnlock(.multiTasker) }

    // Focused: 1 project for 7 days straight
    // Check last 7 days of CachedDailyActivity — if all entries are for the same project
    let weekAgo = Calendar.current.date(byAdding: .day, value: -7, to: today)!
    let weekActivities = activities.filter { $0.date >= weekAgo }
    let weekProjects = Set(weekActivities.map { $0.projectPath })
    if weekProjects.count == 1 && weekActivities.count >= 7 {
        checkAndUnlock(.focused, projectPath: weekProjects.first)
    }
}
```

### Context Master (wire into terminal output monitoring):
Add pattern detection in `TerminalOutputMonitor.processTerminalOutput()`:
```swift
// Detect context percentage from status bar: "Context left until auto-compact: 5%"
// or "Context: 95%" — if context >= 90% and no errors in session
let contextPattern = "Context.*?(\\d+)%"
// Parse and check: if used context >= 90% and no errors detected in this session
```
This one is trickier because you need "no errors in session" state. If it's too complex, add a TODO and move on.

### Collaborator (wire into report generation):
In `ReportGeneratorView` or wherever reports are generated, call:
```swift
AchievementService.shared.checkAndUnlock(.collaborator, projectPath: projectPath)
```

### Launcher (manual — add a "Mark Complete" button):
This is subjective ("complete a project"). Add a button in the project settings or workspace toolbar that lets the user mark a project as complete, which triggers:
```swift
AchievementService.shared.checkAndUnlock(.launcher, projectPath: projectPath)
```

### Pro Supporter:
Leave as-is (StoreKit stub). Will trigger when subscription is implemented.

**Tests:**
- `test_C_streakAchievements_unlockAtThresholds`
- `test_C_sessionCount_unlocksAIWhisperer`
- `test_C_promptCount_unlocksPromptEngineer`
- `test_C_sprinter_unlocksUnderOneHour`


## SCOPE D — Daily Commit XP (Fix First Blood Pattern)

**Modify:** `AchievementService.checkFirstCommitOfDay()`

After the First Blood one-time unlock, add daily XP award that fires every day:
```swift
func checkFirstCommitOfDay(projectPath: String) {
    let todayString = formatDate(Date())

    if lastCommitDateString == todayString {
        return // Already processed today
    }

    lastCommitDateString = todayString

    // One-time achievement
    checkAndUnlock(.firstBlood, projectPath: projectPath)

    // Daily XP bonus (fires every day, not just first time)
    XPService.shared.checkDailyBonus()

    // Check streak achievements
    checkStreakAchievements(projectPath: projectPath)
}
```

**Tests:**
- `test_D_dailyBonus_firesEveryDay`
- `test_D_firstBlood_onlyUnlocksOnce_butDailyXPAlways`


## SCOPE E — Update XP Display

**Find and modify** wherever the XP bar is rendered (likely in the top bar or home page). It currently reads from somewhere — find where `25 / 250 XP` and `Lvl 1` come from and update them to read from `XPService.shared.totalXP` and `XPService.shared.currentLevel`.

Also add a brief XP gain indicator — when `XPService.shared.recentXPGain` is set, show a small "+5 XP" animation or text near the XP bar that fades after a few seconds. Keep it simple — a `Text("+\(amount) XP")` with an opacity animation is fine.

If the XP bar already reads from `@AppStorage` keys that match `XPService`'s keys, this might already work. Verify and adjust if needed.

**Tests:**
- `test_E_xpDisplay_readsFromService`


## PROJECT-SPECIFIC RULES

- CRITICAL: Never use NSWindow level `.screenSaver` — use `.floating` or `.statusBar` max.
- Follow existing patterns: singletons with `.shared`, `@MainActor`, `@AppStorage` for simple counters
- Use existing `AppModelContainer.shared.mainContext` for SwiftData queries
- Don't create new SwiftData models — use existing ones (`AISessionV2`, `SavedPrompt`, `CachedDailyActivity`, `AchievementUnlock`)
- Keep achievement checks lightweight — they run on every commit/push detection
- If an achievement check requires expensive queries (e.g., counting all sessions), consider caching the count and only re-checking periodically
- Context Master achievement: if parsing context % from terminal output is too complex, add a TODO and skip
