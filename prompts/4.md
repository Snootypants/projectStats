Prompt 4: Prompt Manager & File Browser (IDE Mode)
MISSION
Work in the existing repo at /Users/calebbelshe/Code/openProjects/projectStats. Build a new "IDE Mode" view that transforms ProjectStats into a Claude Code command center. This includes a file browser, prompt manager, and quick actions for tCC workflow.
META OUTPUT INSTRUCTIONS (NON-NEGOTIABLE)
You must follow this 4-part response structure:

Plan: outline moves in order, what you will NOT touch
Difficulty: brief estimate and likely failure points
Execute: do the work with strict discipline; minimal edits
Report + self-grade: what changed, why, grade yourself (Aâ€“F)

WORK LOG ARTIFACT (REQUIRED)
Create: /work/YYYY-MM-DD_HHMM_ide-mode-prompt-manager.md
Contents: prompt summary + closing report
STATS TRACKING (REQUIRED)
After each commit, create a stats file:

Location: /work/stats/YYYY-MM-DD_HHMM_[commit-hash].md
Contents:

started: YYYY-MM-DDTHH:MM:SS
ended: YYYY-MM-DDTHH:MM:SS
lines_added: [number]
lines_deleted: [number]
commit: [7-char hash]

Brief description of work completed (under 50 words).
Get line counts from git diff --stat HEAD~1 after committing. Get commit hash from git rev-parse --short HEAD.
COMMIT STRATEGY
Break into logical commits:

"Add file browser tree view component"
"Add prompt manager with create/view functionality"
"Add tCC command generator and clipboard integration"
"Add IDE mode view with tabs and integrated layout"

Push after each commit. Create stats file for each.
PROCESS RULES (NON-NEGOTIABLE)

Follow existing patterns in the codebase
Use SwiftUI best practices
All existing functionality must continue to work
No external dependencies


SCOPE A: File Browser Component
Create a reusable file/folder tree browser.
New File: projectStats/projectStats/Views/IDE/FileBrowserView.swift
swiftimport SwiftUI

struct FileNode: Identifiable, Hashable {
    let id = UUID()
    let name: String
    let path: URL
    let isDirectory: Bool
    var children: [FileNode]?
    var isExpanded: Bool = false
    
    var icon: String {
        if isDirectory {
            return isExpanded ? "folder.fill" : "folder"
        }
        return fileIcon(for: name)
    }
    
    var iconColor: Color {
        if isDirectory { return .blue }
        return fileColor(for: name)
    }
    
    private func fileIcon(for name: String) -> String {
        let ext = (name as NSString).pathExtension.lowercased()
        switch ext {
        case "swift": return "swift"
        case "js", "jsx": return "curlybraces"
        case "ts", "tsx": return "curlybraces"
        case "json": return "doc.text"
        case "md": return "doc.richtext"
        case "py": return "chevron.left.forwardslash.chevron.right"
        case "html": return "globe"
        case "css", "scss": return "paintbrush"
        case "yml", "yaml": return "doc.text"
        default: return "doc"
        }
    }
    
    private func fileColor(for name: String) -> Color {
        let ext = (name as NSString).pathExtension.lowercased()
        switch ext {
        case "swift": return .orange
        case "js", "jsx": return .yellow
        case "ts", "tsx": return .blue
        case "md": return .purple
        case "py": return .green
        case "json": return .gray
        default: return .secondary
        }
    }
}

struct FileBrowserView: View {
    let rootPath: URL
    @Binding var selectedFile: URL?
    @State private var rootNode: FileNode?
    @State private var expandedPaths: Set<URL> = []
    
    // Folders to skip
    private let excludedFolders: Set<String> = [
        "node_modules", ".git", ".next", "dist", "build", 
        ".build", "DerivedData", "Pods", ".swiftpm",
        "__pycache__", ".venv", "venv", "target", ".idea"
    ]
    
    var body: some View {
        ScrollView {
            LazyVStack(alignment: .leading, spacing: 0) {
                if let root = rootNode {
                    FileNodeView(
                        node: root,
                        selectedFile: $selectedFile,
                        expandedPaths: $expandedPaths,
                        level: 0
                    )
                }
            }
            .padding(.vertical, 8)
        }
        .onAppear { loadFileTree() }
        .onChange(of: rootPath) { _, _ in loadFileTree() }
    }
    
    private func loadFileTree() {
        rootNode = buildFileNode(at: rootPath)
    }
    
    private func buildFileNode(at url: URL, depth: Int = 0) -> FileNode? {
        let fm = FileManager.default
        let name = url.lastPathComponent
        
        // Skip excluded folders
        if excludedFolders.contains(name) { return nil }
        
        var isDir: ObjCBool = false
        guard fm.fileExists(atPath: url.path, isDirectory: &isDir) else { return nil }
        
        if isDir.boolValue {
            // Limit depth to prevent performance issues
            guard depth < 10 else { return FileNode(name: name, path: url, isDirectory: true, children: []) }
            
            let contents = (try? fm.contentsOfDirectory(at: url, includingPropertiesForKeys: [.isDirectoryKey], options: [.skipsHiddenFiles])) ?? []
            
            let children = contents
                .sorted { (a, b) -> Bool in
                    let aIsDir = (try? a.resourceValues(forKeys: [.isDirectoryKey]).isDirectory) ?? false
                    let bIsDir = (try? b.resourceValues(forKeys: [.isDirectoryKey]).isDirectory) ?? false
                    if aIsDir != bIsDir { return aIsDir }
                    return a.lastPathComponent.localizedCaseInsensitiveCompare(b.lastPathComponent) == .orderedAscending
                }
                .compactMap { buildFileNode(at: $0, depth: depth + 1) }
            
            return FileNode(name: name, path: url, isDirectory: true, children: children)
        } else {
            return FileNode(name: name, path: url, isDirectory: false, children: nil)
        }
    }
}

struct FileNodeView: View {
    let node: FileNode
    @Binding var selectedFile: URL?
    @Binding var expandedPaths: Set<URL>
    let level: Int
    
    private var isExpanded: Bool {
        expandedPaths.contains(node.path)
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            HStack(spacing: 4) {
                // Indent based on level
                if level > 0 {
                    Spacer()
                        .frame(width: CGFloat(level) * 16)
                }
                
                // Expand/collapse for directories
                if node.isDirectory {
                    Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                        .font(.caption2)
                        .foregroundStyle(.secondary)
                        .frame(width: 12)
                } else {
                    Spacer().frame(width: 12)
                }
                
                // Icon
                Image(systemName: node.icon)
                    .font(.system(size: 14))
                    .foregroundStyle(node.iconColor)
                    .frame(width: 18)
                
                // Name
                Text(node.name)
                    .font(.system(size: 13))
                    .lineLimit(1)
                
                Spacer()
            }
            .padding(.vertical, 4)
            .padding(.horizontal, 8)
            .background(selectedFile == node.path ? Color.accentColor.opacity(0.2) : Color.clear)
            .contentShape(Rectangle())
            .onTapGesture {
                if node.isDirectory {
                    withAnimation(.easeInOut(duration: 0.15)) {
                        if isExpanded {
                            expandedPaths.remove(node.path)
                        } else {
                            expandedPaths.insert(node.path)
                        }
                    }
                } else {
                    selectedFile = node.path
                }
            }
            
            // Children (if expanded)
            if node.isDirectory && isExpanded, let children = node.children {
                ForEach(children) { child in
                    FileNodeView(
                        node: child,
                        selectedFile: $selectedFile,
                        expandedPaths: $expandedPaths,
                        level: level + 1
                    )
                }
            }
        }
    }
}

SCOPE B: File Viewer with Tabs
New File: projectStats/projectStats/Views/IDE/FileViewerView.swift
swiftimport SwiftUI

struct OpenFile: Identifiable, Equatable {
    let id = UUID()
    let path: URL
    var content: String
    
    var name: String { path.lastPathComponent }
    
    static func == (lhs: OpenFile, rhs: OpenFile) -> Bool {
        lhs.path == rhs.path
    }
}

struct FileViewerView: View {
    @Binding var openFiles: [OpenFile]
    @Binding var activeFileID: UUID?
    
    var activeFile: OpenFile? {
        guard let id = activeFileID else { return openFiles.first }
        return openFiles.first { $0.id == id }
    }
    
    var body: some View {
        VStack(spacing: 0) {
            // Tab bar
            if !openFiles.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 0) {
                        ForEach(openFiles) { file in
                            FileTab(
                                file: file,
                                isActive: file.id == (activeFileID ?? openFiles.first?.id),
                                onSelect: { activeFileID = file.id },
                                onClose: { closeFile(file) }
                            )
                        }
                    }
                }
                .background(Color.primary.opacity(0.05))
                
                Divider()
            }
            
            // Content
            if let file = activeFile {
                ScrollView {
                    Text(file.content)
                        .font(.system(size: 12, design: .monospaced))
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding()
                        .textSelection(.enabled)
                }
            } else {
                VStack {
                    Spacer()
                    Image(systemName: "doc.text")
                        .font(.system(size: 48))
                        .foregroundStyle(.tertiary)
                    Text("Select a file to view")
                        .foregroundStyle(.secondary)
                    Spacer()
                }
            }
        }
    }
    
    private func closeFile(_ file: OpenFile) {
        if let index = openFiles.firstIndex(of: file) {
            openFiles.remove(at: index)
            if activeFileID == file.id {
                activeFileID = openFiles.first?.id
            }
        }
    }
}

struct FileTab: View {
    let file: OpenFile
    let isActive: Bool
    let onSelect: () -> Void
    let onClose: () -> Void
    
    @State private var isHovering = false
    
    var body: some View {
        HStack(spacing: 6) {
            Text(file.name)
                .font(.system(size: 12))
                .lineLimit(1)
            
            Button(action: onClose) {
                Image(systemName: "xmark")
                    .font(.system(size: 9, weight: .semibold))
                    .foregroundStyle(.secondary)
            }
            .buttonStyle(.plain)
            .opacity(isHovering ? 1 : 0)
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .background(isActive ? Color.primary.opacity(0.1) : Color.clear)
        .overlay(
            Rectangle()
                .frame(height: 2)
                .foregroundStyle(isActive ? Color.accentColor : Color.clear),
            alignment: .bottom
        )
        .contentShape(Rectangle())
        .onTapGesture(perform: onSelect)
        .onHover { isHovering = $0 }
    }
}

SCOPE C: Prompt Manager
New File: projectStats/projectStats/Views/IDE/PromptManagerView.swift
swiftimport SwiftUI

struct PromptFile: Identifiable {
    let id = UUID()
    let number: Int
    let path: URL
    var content: String
    
    var name: String { "\(number).md" }
}

struct PromptManagerView: View {
    let projectPath: URL
    @State private var prompts: [PromptFile] = []
    @State private var selectedPrompt: PromptFile?
    @State private var newPromptText: String = ""
    @State private var isCreatingNew: Bool = false
    @State private var showCopiedAlert: Bool = false
    
    private var promptsPath: URL {
        projectPath.appendingPathComponent("prompts")
    }
    
    private var nextPromptNumber: Int {
        (prompts.map { $0.number }.max() ?? 0) + 1
    }
    
    private var tccCommand: String {
        let promptNum = selectedPrompt?.number ?? nextPromptNumber
        return "read /prompts/\(promptNum).md and execute. Push all your commits after you wrap up."
    }
    
    var body: some View {
        VStack(spacing: 0) {
            // Prompt tabs
            promptTabBar
            
            Divider()
            
            // Content area
            if isCreatingNew {
                newPromptEditor
            } else if let prompt = selectedPrompt {
                existingPromptViewer(prompt)
            } else {
                emptyState
            }
            
            Divider()
            
            // Bottom action bar
            actionBar
        }
        .onAppear { loadPrompts() }
    }
    
    // MARK: - Prompt Tab Bar
    
    private var promptTabBar: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 0) {
                ForEach(prompts) { prompt in
                    PromptTab(
                        prompt: prompt,
                        isSelected: selectedPrompt?.id == prompt.id,
                        onSelect: {
                            isCreatingNew = false
                            selectedPrompt = prompt
                        }
                    )
                }
                
                // New prompt tab
                Button {
                    isCreatingNew = true
                    selectedPrompt = nil
                } label: {
                    HStack(spacing: 4) {
                        Image(systemName: "plus")
                        Text("New")
                    }
                    .font(.system(size: 12))
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(isCreatingNew ? Color.accentColor.opacity(0.2) : Color.clear)
                }
                .buttonStyle(.plain)
                
                Spacer()
            }
            .padding(.horizontal, 8)
        }
        .frame(height: 40)
        .background(Color.primary.opacity(0.03))
    }
    
    // MARK: - New Prompt Editor
    
    private var newPromptEditor: some View {
        VStack(spacing: 0) {
            HStack {
                Text("New Prompt: \(nextPromptNumber).md")
                    .font(.headline)
                Spacer()
            }
            .padding()
            
            TextEditor(text: $newPromptText)
                .font(.system(size: 13, design: .monospaced))
                .padding(8)
                .background(Color.primary.opacity(0.03))
                .clipShape(RoundedRectangle(cornerRadius: 8))
                .padding(.horizontal)
            
            HStack {
                Button("Clear") {
                    newPromptText = ""
                }
                .buttonStyle(.bordered)
                
                Spacer()
                
                Button("Save as \(nextPromptNumber).md") {
                    saveNewPrompt()
                }
                .buttonStyle(.borderedProminent)
                .disabled(newPromptText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
            }
            .padding()
        }
    }
    
    // MARK: - Existing Prompt Viewer
    
    private func existingPromptViewer(_ prompt: PromptFile) -> some View {
        VStack(spacing: 0) {
            HStack {
                Text("Prompt \(prompt.number)")
                    .font(.headline)
                Spacer()
                
                Text("\(prompt.content.count) characters")
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
            .padding()
            
            ScrollView {
                Text(prompt.content)
                    .font(.system(size: 13, design: .monospaced))
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding()
                    .textSelection(.enabled)
            }
            .background(Color.primary.opacity(0.03))
            .clipShape(RoundedRectangle(cornerRadius: 8))
            .padding(.horizontal)
            .padding(.bottom)
        }
    }
    
    // MARK: - Empty State
    
    private var emptyState: some View {
        VStack(spacing: 16) {
            Spacer()
            Image(systemName: "doc.badge.plus")
                .font(.system(size: 48))
                .foregroundStyle(.tertiary)
            Text("No prompts yet")
                .font(.title3)
                .foregroundStyle(.secondary)
            Text("Click 'New' to create your first prompt")
                .font(.caption)
                .foregroundStyle(.tertiary)
            Spacer()
        }
    }
    
    // MARK: - Action Bar
    
    private var actionBar: some View {
        VStack(spacing: 12) {
            // tCC Command Display
            HStack {
                Text(tccCommand)
                    .font(.system(size: 11, design: .monospaced))
                    .foregroundStyle(.secondary)
                    .lineLimit(1)
                
                Spacer()
                
                Button {
                    copyTCCCommand()
                } label: {
                    HStack(spacing: 4) {
                        Image(systemName: showCopiedAlert ? "checkmark" : "doc.on.doc")
                        Text(showCopiedAlert ? "Copied!" : "Copy tCC Command")
                    }
                    .font(.system(size: 12))
                }
                .buttonStyle(.borderedProminent)
                .tint(showCopiedAlert ? .green : .accentColor)
            }
            
            // Quick actions
            HStack {
                Button {
                    openInClaudeCode()
                } label: {
                    Label("Open in Claude Code", systemImage: "terminal")
                }
                .buttonStyle(.bordered)
                
                Spacer()
                
                Button {
                    openPromptsFolder()
                } label: {
                    Label("Open Prompts Folder", systemImage: "folder")
                }
                .buttonStyle(.bordered)
            }
        }
        .padding()
        .background(Color.primary.opacity(0.03))
    }
    
    // MARK: - Actions
    
    private func loadPrompts() {
        let fm = FileManager.default
        
        // Create prompts folder if it doesn't exist
        if !fm.fileExists(atPath: promptsPath.path) {
            try? fm.createDirectory(at: promptsPath, withIntermediateDirectories: true)
        }
        
        guard let contents = try? fm.contentsOfDirectory(at: promptsPath, includingPropertiesForKeys: nil) else {
            prompts = []
            return
        }
        
        prompts = contents
            .filter { $0.pathExtension == "md" }
            .compactMap { url -> PromptFile? in
                let name = url.deletingPathExtension().lastPathComponent
                guard let number = Int(name) else { return nil }
                let content = (try? String(contentsOf: url, encoding: .utf8)) ?? ""
                return PromptFile(number: number, path: url, content: content)
            }
            .sorted { $0.number < $1.number }
        
        // Select the latest prompt by default
        if selectedPrompt == nil && !isCreatingNew {
            selectedPrompt = prompts.last
        }
    }
    
    private func saveNewPrompt() {
        let fileName = "\(nextPromptNumber).md"
        let filePath = promptsPath.appendingPathComponent(fileName)
        
        do {
            // Create prompts directory if needed
            try FileManager.default.createDirectory(at: promptsPath, withIntermediateDirectories: true)
            
            // Write the file
            try newPromptText.write(to: filePath, atomically: true, encoding: .utf8)
            
            // Reload and select the new prompt
            loadPrompts()
            selectedPrompt = prompts.last
            isCreatingNew = false
            newPromptText = ""
        } catch {
            print("Failed to save prompt: \(error)")
        }
    }
    
    private func copyTCCCommand() {
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(tccCommand, forType: .string)
        
        showCopiedAlert = true
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            showCopiedAlert = false
        }
    }
    
    private func openInClaudeCode() {
        // Open terminal at project path and run claude
        let script = """
        tell application "Terminal"
            activate
            do script "cd '\(projectPath.path)' && claude"
        end tell
        """
        
        if let appleScript = NSAppleScript(source: script) {
            var error: NSDictionary?
            appleScript.executeAndReturnError(&error)
        }
    }
    
    private func openPromptsFolder() {
        NSWorkspace.shared.selectFile(nil, inFileViewerRootedAtPath: promptsPath.path)
    }
}

struct PromptTab: View {
    let prompt: PromptFile
    let isSelected: Bool
    let onSelect: () -> Void
    
    var body: some View {
        Button(action: onSelect) {
            Text("\(prompt.number).md")
                .font(.system(size: 12, design: .monospaced))
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
                .background(isSelected ? Color.accentColor.opacity(0.2) : Color.clear)
                .clipShape(RoundedRectangle(cornerRadius: 4))
        }
        .buttonStyle(.plain)
    }
}

SCOPE D: IDE Mode View (Main Container)
New File: projectStats/projectStats/Views/IDE/IDEModeView.swift
swiftimport SwiftUI

struct IDEModeView: View {
    let project: Project
    
    @State private var selectedFile: URL?
    @State private var openFiles: [OpenFile] = []
    @State private var activeFileID: UUID?
    @State private var showPromptManager: Bool = true
    @State private var sidebarWidth: CGFloat = 250
    
    var body: some View {
        HSplitView {
            // Left sidebar - File Browser
            VStack(spacing: 0) {
                // Project header
                HStack {
                    Image(systemName: "folder.fill")
                        .foregroundStyle(.blue)
                    Text(project.name)
                        .font(.headline)
                        .lineLimit(1)
                    Spacer()
                }
                .padding()
                .background(Color.primary.opacity(0.03))
                
                Divider()
                
                // File tree
                FileBrowserView(
                    rootPath: project.path,
                    selectedFile: $selectedFile
                )
            }
            .frame(minWidth: 200, idealWidth: 250, maxWidth: 350)
            
            // Right side - Content
            VStack(spacing: 0) {
                // Toggle between File Viewer and Prompt Manager
                HStack(spacing: 0) {
                    Button {
                        showPromptManager = false
                    } label: {
                        Label("Files", systemImage: "doc.text")
                            .padding(.horizontal, 16)
                            .padding(.vertical, 8)
                            .background(showPromptManager ? Color.clear : Color.accentColor.opacity(0.2))
                    }
                    .buttonStyle(.plain)
                    
                    Button {
                        showPromptManager = true
                    } label: {
                        Label("Prompts", systemImage: "text.badge.plus")
                            .padding(.horizontal, 16)
                            .padding(.vertical, 8)
                            .background(showPromptManager ? Color.accentColor.opacity(0.2) : Color.clear)
                    }
                    .buttonStyle(.plain)
                    
                    Spacer()
                    
                    // Quick actions
                    quickActions
                }
                .background(Color.primary.opacity(0.03))
                
                Divider()
                
                // Content
                if showPromptManager {
                    PromptManagerView(projectPath: project.path)
                } else {
                    FileViewerView(
                        openFiles: $openFiles,
                        activeFileID: $activeFileID
                    )
                }
            }
        }
        .onChange(of: selectedFile) { _, newValue in
            if let path = newValue {
                openFile(at: path)
                showPromptManager = false
            }
        }
    }
    
    private var quickActions: some View {
        HStack(spacing: 8) {
            Button {
                openInVSCode()
            } label: {
                Image(systemName: "chevron.left.forwardslash.chevron.right")
            }
            .buttonStyle(.plain)
            .help("Open in VSCode")
            
            Button {
                openInFinder()
            } label: {
                Image(systemName: "folder")
            }
            .buttonStyle(.plain)
            .help("Open in Finder")
            
            Button {
                openInTerminal()
            } label: {
                Image(systemName: "terminal")
            }
            .buttonStyle(.plain)
            .help("Open in Terminal")
            
            if let url = project.githubURL, let _ = URL(string: url) {
                Button {
                    openGitHub()
                } label: {
                    Image(systemName: "link")
                }
                .buttonStyle(.plain)
                .help("Open on GitHub")
            }
        }
        .padding(.horizontal)
    }
    
    // MARK: - File Management
    
    private func openFile(at path: URL) {
        // Check if already open
        if let existing = openFiles.first(where: { $0.path == path }) {
            activeFileID = existing.id
            return
        }
        
        // Load content
        guard let content = try? String(contentsOf: path, encoding: .utf8) else { return }
        
        let newFile = OpenFile(path: path, content: content)
        openFiles.append(newFile)
        activeFileID = newFile.id
    }
    
    // MARK: - Quick Actions
    
    private func openInVSCode() {
        Shell.run("open -a 'Visual Studio Code' '\(project.path.path)'")
    }
    
    private func openInFinder() {
        NSWorkspace.shared.selectFile(nil, inFileViewerRootedAtPath: project.path.path)
    }
    
    private func openInTerminal() {
        let script = """
        tell application "Terminal"
            activate
            do script "cd '\(project.path.path)'"
        end tell
        """
        
        if let appleScript = NSAppleScript(source: script) {
            var error: NSDictionary?
            appleScript.executeAndReturnError(&error)
        }
    }
    
    private func openGitHub() {
        guard let urlString = project.githubURL, let url = URL(string: urlString) else { return }
        NSWorkspace.shared.open(url)
    }
}

SCOPE E: Integrate IDE Mode into App
File to modify: projectStats/projectStats/Views/Dashboard/DashboardView.swift
Add IDE Mode as a navigation destination when clicking a project. Modify the ProjectsTab or add a new way to open IDE mode.
Add a button in ProjectDetailView or ProjectRowView:
swiftButton {
    // Open IDE Mode for this project
    openIDEMode(for: project)
} label: {
    Label("Open IDE", systemImage: "rectangle.split.3x1")
}
File to modify: projectStats/projectStats/App/ProjectStatsApp.swift
Add a new WindowGroup for IDE mode:
swiftWindowGroup(for: Project.ID.self) { $projectID in
    if let projectID = projectID,
       let project = dashboardViewModel.projects.first(where: { $0.id == projectID }) {
        IDEModeView(project: project)
    }
}
.windowStyle(.hiddenTitleBar)
.defaultSize(width: 1200, height: 800)
Or simpler - add IDE mode as a tab/view within the existing project detail view using a toggle or segmented control.

SCOPE F: Navigation Integration
File to modify: projectStats/projectStats/Views/Projects/ProjectDetailView.swift
Add a toggle or button to switch to IDE mode:
swift@State private var showIDEMode = false

var body: some View {
    VStack {
        if showIDEMode {
            IDEModeView(project: project)
        } else {
            // Existing detail view content
            existingDetailContent
        }
    }
    .toolbar {
        ToolbarItem {
            Button {
                showIDEMode.toggle()
            } label: {
                Label(
                    showIDEMode ? "Show Details" : "Open IDE",
                    systemImage: showIDEMode ? "info.circle" : "rectangle.split.3x1"
                )
            }
        }
    }
}

VERIFICATION CHECKLIST

 Build succeeds
 File browser shows project structure
 Clicking files opens them in viewer with tabs
 Can close file tabs
 Prompt manager shows existing prompts in /prompts
 Can create new prompt with auto-numbered filename
 Save button creates the .md file
 "Copy tCC Command" copies correct command to clipboard
 "Open in Claude Code" opens terminal with claude command
 Quick actions work (VSCode, Finder, Terminal, GitHub)
 Excluded folders (node_modules, .git, etc.) are hidden
 All existing functionality still works

FINAL RESPONSE REQUIREMENTS

Follow 4-part structure
List all files created/modified
Confirm build passes
Include all commit hashes
Confirm stats files created for each commit

DO NOT:

Break existing dashboard/overview functionality
Add external dependencies
Make the file browser editable (read-only for now)
Overcomplicate - keep it functional first, pretty later
Skip creating stats files for each commit